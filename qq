[1mdiff --git a/Makefile b/Makefile[m
[1mindex d4e3a2a..ab66deb 100644[m
[1m--- a/Makefile[m
[1m+++ b/Makefile[m
[36m@@ -9,7 +9,7 @@[m [mLEXER_PATH = parsing/lexer/[m
 EXEC_PATH = exec/[m
 BUILTIN_PATH = exec/builtins/[m
 EXECUTIVE_PATH = exec/executive/[m
[31m-ENV_PATH = exec/builtins/env.c/[m
[32m+[m[32mENV_PATH = exec/builtins/env/[m
 GARB_PATH = parsing/garb_col/[m
 [m
 OBJ_PATH = build/[m
[1mdiff --git a/exec/builtins/env.c/create_add_env.c b/exec/builtins/env/create_add_env.c[m
[1msimilarity index 100%[m
[1mrename from exec/builtins/env.c/create_add_env.c[m
[1mrename to exec/builtins/env/create_add_env.c[m
[1mdiff --git a/exec/builtins/env.c/ft_env.c b/exec/builtins/env/ft_env.c[m
[1msimilarity index 84%[m
[1mrename from exec/builtins/env.c/ft_env.c[m
[1mrename to exec/builtins/env/ft_env.c[m
[1mindex 6236604..88c49dc 100644[m
[1m--- a/exec/builtins/env.c/ft_env.c[m
[1m+++ b/exec/builtins/env/ft_env.c[m
[36m@@ -5,6 +5,8 @@[m [mint	ft_env(t_minishell *mini)[m
 	int	i;[m
 [m
 	i = 0;[m
[32m+[m	[32mif (!mini->env)[m
[32m+[m		[32mreturn (0);[m
 	while (mini->env[i])[m
 	{[m
 		ft_putstr_fd(mini->env[i], 1);[m
[1mdiff --git a/exec/builtins/env.c/update_ft_env.c b/exec/builtins/env/update_ft_env.c[m
[1msimilarity index 100%[m
[1mrename from exec/builtins/env.c/update_ft_env.c[m
[1mrename to exec/builtins/env/update_ft_env.c[m
[1mdiff --git a/exec/builtins/export.c b/exec/builtins/export.c[m
[1mindex 105c306..5f5b58d 100644[m
[1m--- a/exec/builtins/export.c[m
[1m+++ b/exec/builtins/export.c[m
[36m@@ -26,10 +26,10 @@[m [mchar	**ft_create_export(t_minishell *mini)[m
 	int	i;[m
 	char **exp;[m
 [m
[31m-	exp = ft_malloc(sizeof(char *) * (ft_strlen_y(mini->env) + 1), &mini->alloc);[m
[31m-	printf("debug: %p\n both line should be the same\n", (void *)exp);[m
 	if (!mini->env)[m
 		return (0);[m
[32m+[m	[32mexp = ft_malloc(sizeof(char *) * (ft_strlen_y(mini->env) + 1), &mini->alloc);[m
[32m+[m	[32mprintf("debug: %p\n both line should be the same\n", (void *)exp);[m
 	i = 0;[m
 	while (mini->env[i])[m
 	{[m
[36m@@ -76,26 +76,25 @@[m [mvoid	ft_export(t_minishell *mini, char **cmd)[m
 	int	i;[m
 	char **exp;[m
 [m
[32m+[m	[32mif (cmd[1])[m
[32m+[m	[32m{[m
[32m+[m		[32mprint_env(cmd);[m
[32m+[m		[32mprintf("cmd[1] == %s\n", cmd[1]);[m
[32m+[m		[32mft_update_env(mini, cmd[1]);[m
[32m+[m		[32mreturn ;[m
[32m+[m	[32m}[m
 	exp = ft_create_export(mini);[m
[32m+[m	[32mif (!exp)[m
[32m+[m		[32mreturn ;[m
 	ft_update_env(mini, *exp);[m
 	ft_sort_export(exp);[m
[31m-	if (!exp)[m
[31m-		return;[m
 	i = 0;[m
[31m-	if (!cmd[1])[m
[32m+[m	[32mwhile (exp[i])[m
 	{[m
[31m-		while (exp[i])[m
[31m-		{[m
[31m-				ft_putstr_fd("export ", 1);[m
[31m-				ft_putstr_fd(exp[i], 1);[m
[31m-				ft_putchar_fd('\n', 1);[m
[31m-				i++;[m
[31m-		}[m
[31m-	}[m
[31m-	else[m
[31m-	{[m
[31m-		print_env(cmd);[m
[31m-		printf("cmd[1] == %s\n", cmd[1]);[m
[31m-		ft_update_env(mini, cmd[1]);[m
[32m+[m			[32mft_putstr_fd("export ", 1);[m
[32m+[m			[32mft_putstr_fd(exp[i], 1);[m
[32m+[m			[32mft_putchar_fd('\n', 1);[m
[32m+[m			[32mi++;[m
 	}[m
[32m+[m	[32mreturn ;[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/exec/hitman.c b/exec/hitman.c[m
[1mindex 8bc54ad..7b97a68 100644[m
[1m--- a/exec/hitman.c[m
[1m+++ b/exec/hitman.c[m
[36m@@ -56,6 +56,8 @@[m [mchar	*find_path(char *cmd, char **envp)[m
 	char	*part_path;[m
 [m
 	i = 0;[m
[32m+[m	[32mif (!envp)[m
[32m+[m		[32mreturn ("");[m
 	while (ft_strnstr(envp[i], "PATH", 4) == 0)[m
 		i++;[m
 	paths = ft_split(envp[i] + 5, ':');[m
[36m@@ -124,8 +126,7 @@[m [mvoid exec_mult(t_cmd *cmd, t_minishell *mini)[m
             }[m
             if (is_a_builtin(current->args, mini, 1))[m
                 exit(0);[m
[31m-            if (mini->env)[m
[31m-				path = find_path(current->args[0], mini->env);[m
[32m+[m[32m            path = find_path(current->args[0], mini->env);[m
             if (!path)[m
             {[m
                 ft_putstr_fd("Command not found: ", 2);[m
[36m@@ -183,8 +184,6 @@[m [mvoid	exec_single(char **cmd, char **envp)[m
 	}[m
 	else [m
 	{[m
[31m-		if (!envp)[m
[31m-			return;[m
 		path = find_path(cmd[0], envp);[m
 		if (!path)	[m
 		{[m
[1mdiff --git a/parsing/parsinette.c b/parsing/parsinette.c[m
[1mindex 867c896..5330223 100644[m
[1m--- a/parsing/parsinette.c[m
[1m+++ b/parsing/parsinette.c[m
[36m@@ -128,22 +128,17 @@[m [mint parsinette(t_minishell *minishell)[m
 		return (1);[m
 	cmd = NULL;[m
     tokens = tokenize(minishell->input);[m
[31m-	print_token(tokens);[m
 	if (!tokens)[m
         return (1);[m
     if(!list_expand(minishell, tokens))[m
 		return (1);[m
[31m-	print_token(tokens);[m
 	if (!do_field_spliting(tokens))[m
 		return (1);[m
[31m-	print_token(tokens);[m
 	if (!remove_all_quote(tokens))[m
 		return (1);[m
[31m-	print_token(tokens);[m
 	if (!check_syntax_errors(tokens))[m
 		return (1);[m
 	cmd = lexer(tokens, cmd);[m
[31m-	print_lexer(cmd);[m
 	execute(cmd, minishell);[m
     return (0);[m
 }[m
[1mdiff --git a/src/main.c b/src/main.c[m
[1mindex 1179ce2..6fb7ff5 100644[m
[1m--- a/src/main.c[m
[1m+++ b/src/main.c[m
[36m@@ -9,10 +9,10 @@[m [mint main(int ac, char **av, char **ev)[m
     t_minishell *minishell;[m
 [m
     minishell = malloc(sizeof(t_minishell));[m
[31m-    prompt = "\001\033[1;36m\002RicoShell \001\033[0;95m\002\001‚ûú\002 \001\033[0m\002";[m
[31m-    //prompt = "\001\033[32m\002minishell$ \001\033[0m\002";[m
[31m-[m
[31m-[m
[32m+[m	[32m// ft_bzero(&minishell, sizeof(t_minishell));[m
[32m+[m	[32mminishell->env = NULL;[m
[32m+[m[32m    prompt = BOLD CYAN "RicoShell" RESET PINK " ‚ûú " RESET;[m
[32m+[m[41m    [m
     set_struct_minishell(minishell, ev); //ici remplir env [m
 [m
     while (42)[m
[36m@@ -21,7 +21,7 @@[m [mint main(int ac, char **av, char **ev)[m
             break;[m
 [m
         minishell->input = readline(prompt);[m
[31m-        if (!minishell->input) // est-ce que readline peut fail ?[m
[32m+[m[32m        if (!minishell->input) // ctrl d[m
             return(printf("Exit\n"), 0);[m
         add_history(minishell->input);[m
         //printf("Debug :\nString sent by readline : %s\n", minishell->input);[m
[1mdiff --git a/test result b/test result[m
[1mindex b6771ca..887a754 100644[m
[1m--- a/test result[m	
[1m+++ b/test result[m	
[36m@@ -11,38 +11,24 @@[m [mDebug output - Tests 24-32: Shows debug information that shouldn't be printed[m
 Exit code handling - All export tests show "is gonna be freed" instead of proper exit codes[m
 Error messages - Missing proper error messages for invalid identifiers[m
 Multiple arguments - Doesn't handle multiple export arguments correctly[m
[31m-[m
[31m-[m
 Unset Command Problems:[m
 Error output - Tests 33-38: Shows "unset" error message when it should be silent[m
[31m-[m
 CD Command Problems:[m
 Error handling - Tests 40-41: Wrong exit codes and missing proper error messages[m
 Too many arguments - Should return exit code 1 with proper error message[m
 Exit Command Problems:[m
 Error messages - Tests 50-51: Wrong exit codes and different error message format[m
[31m-[m
[31m-[m
 Empty Command Problem:[m
 Parsing failure - Test 52: Should handle empty input gracefully[m
[31m-[m
[31m-[m
[31m-[m
 üîÄ Pipes Issues[m
 Grep with special characters - Test 55: Exit code mismatch[m
 Export in pipeline - Test 56: Export doesn't work properly in pipelines[m
[31m-[m
[31m-[m
[31m-[m
 üìÅ Redirections Issues[m
[31m-[m
 Input Redirection Problems:[m
 Basic input redirection - Tests 57, 60, 67, 68, 74: Input redirection not working properly[m
 File with spaces - Test 62: Segfault (exit code 139) when handling files with spaces[m
 Multiple input files - Test 58: Wrong behavior with multiple input redirections[m
 Missing file handling - Tests 64-66, 76-80: Wrong exit codes and missing error messages[m
[31m-[m
[31m-[m
 Output Redirection Problems:[m
 All output redirection tests failing - Tests 81-131: Output is going to stdout instead of files[m
 File permissions - Tests 85, 88-89, etc.: Wrong exit codes for permission denied[m
[36m@@ -50,26 +36,17 @@[m [mFile with spaces - Test 86: Segfault when creating files with spaces in name[m
 General Redirection Issues:[m
 Pipe combinations - Tests 71, 73, 75: Wrong behavior when combining pipes with redirections[m
 Error propagation - Many tests show wrong exit codes and missing error messages[m
[31m-[m
[31m-[m
[31m-[m
 üéØ Extras/General Issues[m
[31m-[m
 Command Execution Problems:[m
 Variable expansion as commands - Tests 133, 135: Wrong exit codes when using variables as commands[m
 File execution - Tests 136-146: All command execution tests fail with wrong exit codes and error messages[m
 Permission handling - Wrong error messages and exit codes for permission denied[m
 Missing commands - Should return 127 for command not found, but returns 0[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
 Core Issues:[m
 Exit code handling - Many commands return 0 when they should return non-zero[m
 Error message format - Error messages don't match bash format[m
 Memory management - Segfaults in file handling with spaces[m
 Parsing - Empty command handling needs improvement[m
[31m-[m
 üèóÔ∏è Priority Fix Order:[m
 High Priority: Exit codes, error message formatting, basic redirection functionality[m
 Medium Priority: Quote handling in echo, export debugging output, command execution[m
